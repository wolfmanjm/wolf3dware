require 'rake'
require 'pathname'
require 'fileutils'

verbose(ENV['verbose'] == '1')

PROG = 'Wolf3dWare'

# compile for the STM32F405 if true, adding discovery=1 to command line will force it to F429
F405 = ENV['discovery'].nil? ? true : false

# stamp=1 will select stamp otherwise olimex
OLIMEX = ENV['stamp'].nil? ? true : false

TARGET = F405 ? ((OLIMEX ? "OLIMEX" : "STAMP") + "-STM32F405") : "STM32F429"

DEBUG = ENV['debug'] == '1'

$using_cpp= false

def pop_path(path)
  Pathname(path).each_filename.to_a[1..-1]
end

def obj2src(fn, e)
  File.absolute_path(File.join(PROG, pop_path(File.dirname(fn)), File.basename(fn).ext(e)))
end

# Makefile .d file loader to be used with the import file loader.
# this emulates the -include $(DEPFILES) in a Makefile for the generated .d files
class DfileLoader
  include Rake::DSL

  SPACE_MARK = "\0"

  # Load the makefile dependencies in +fn+.
  def load(fn)
    return if ! File.exists?(fn)
    lines = File.read fn
    lines.gsub!(/\\ /, SPACE_MARK)
    lines.gsub!(/#[^\n]*\n/m, "")
    lines.gsub!(/\\\n/, ' ')
    lines.each_line do |line|
      process_line(line)
    end
  end

  private

  # Process one logical line of makefile data.
  def process_line(line)
    file_tasks, args = line.split(':', 2)
    return if args.nil?
    dependents = args.split.map { |d| respace(d) }
    file_tasks.scan(/\S+/) do |file_task|
      file_task = respace(file_task)
      file file_task => dependents
    end
  end

  def respace(str)
    str.tr SPACE_MARK, ' '
  end
end

# Install the handler
Rake.application.add_loader('d', DfileLoader.new)

#TOOLSDIR = '/home/morris/work/reprap/Smoothie/gcc-arm-none-eabi/bin'
TOOLSDIR = ENV['ARMTOOLS'].nil? ? '/usr/bin' :  ENV['ARMTOOLS']
TOOLSBIN = "#{TOOLSDIR}/arm-none-eabi-"
CC = "#{TOOLSBIN}gcc"
CCPP = "#{TOOLSBIN}g++"
LD = "#{TOOLSBIN}gcc"
LDCPP = "#{TOOLSBIN}g++"
OBJCOPY = "#{TOOLSBIN}objcopy"
OBJDUMP = "#{TOOLSBIN}objdump"
SIZE = "#{TOOLSBIN}size"
AR = "#{TOOLSBIN}ar"

ARFLAGS = 'cr'

# include a defaults file if present
load 'rakefile.defaults' if File.exists?('rakefile.defaults')

# Set build type
#BUILDTYPE= ENV['BUILDTYPE'] || 'Checked' unless defined? BUILDTYPE
#puts "#{BUILDTYPE} build"

# include and exclude different files depending on the build target
excludes= F405 ? ["BSP/", "Components/", "Fonts/", "lcd*", "TimingTests.cpp", "startup_stm32f429xx.s"] : ["startup_stm32f405xx.s", "STM32F405-BSP.c"]
SRC = FileList[PROG + '/**/*.{c,cpp,s}']
SRC.exclude(/#{excludes.join('|')}/) unless excludes.empty?
$using_cpp= SRC.find { |i| File.extname(i) == ".cpp" }.nil? ? false : true

OBJDIR = "#{PROG}_#{TARGET}"
OBJ = SRC.collect { |fn| File.join(OBJDIR, pop_path(File.dirname(fn)), File.basename(fn).ext('o')) }
    # + %W(#{OBJDIR}/configdefault.o #{OBJDIR}/mbed_custom.o)

# list of header dependency files generated by compiler
DEPFILES = OBJ.collect { |fn| File.join(File.dirname(fn), File.basename(fn).ext('d')) }

# create destination directories
SRC.each do |s|
  d= File.join(OBJDIR, pop_path(File.dirname(s)))
  FileUtils.mkdir_p(d) unless Dir.exists?(d)
end

include_dirs = ["#{PROG}/STM32F4xx_HAL_Driver/Inc", "#{PROG}/CMSIS/Include", "#{PROG}/CMSIS/Device/ST/STM32F4xx/Include", "#{PROG}/Inc"] +
                ["#{PROG}/FreeRTOS/Source/include", "#{PROG}/FreeRTOS/Source/CMSIS_RTOS", "#{PROG}/USB/Inc", "#{PROG}/USB/CDC/Inc" ]
if !F405
  include_dirs += ["#{PROG}/BSP"]
end

# [Dir.glob([PROG + '/**/Inc/**', './mri/**/'])].flatten

INCLUDE = (include_dirs).collect { |d| "-I#{d}" }.join(" ")

#SYS_LIBS = '-lstdc++_s -lsupc++_s -lm -lgcc -lc_s -lgcc -lc_s -lnosys'
SYS_LIBS = []
HAL_LIBS = []
LIBS = [HAL_LIBS, SYS_LIBS].flatten.collect{ |l| "-l#{l}" }.join(' ')

if F405
  defines = %w(-DUSE_HAL_DRIVER  -DSTM32F405xx -DUSE_USB_FS)
else
  defines = %w(-DUSE_HAL_DRIVER -DUSE_STM32F429I_DISCO -DSTM32F429xx -DUSE_USB_HS -DUSE_USB_HS_IN_FS )
end

if OLIMEX
  defines += %w(-DOLIMEX)
end

DEFINES= defines.join(' ')

# Compiler flags used to enable creation of header dependencies.
# -gcc -c -mthumb -mcpu=cortex-m4 -mfloat-abi=softfp -mfpu=fpv4-sp-d16 -std=gnu90 -DSTM32F429xx -DUSE_STM32F429I_DISCO -I..\..\..\Inc -I..\..\..\..\..\..\..\Drivers\CMSIS\Device\ST\STM32F4xx\Include -I..\..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\inc -I..\..\..\..\..\..\..\Drivers\BSP\STM32F429I-Discovery -I..\..\..\..\..\..\..\Utilities\Log -I..\..\..\..\..\..\..\Drivers\CMSIS\Include -Os -ffunction-sections -fdata-sections -g -Wall -Wno-unused-but-set-variable -o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_pcd.o ..\..\..\..\..\..\..\Drivers\STM32F4xx_HAL_Driver\Src\stm32f4xx_hal_pcd.c
DEPFLAGS = '-MMD '
CSTD = '-std=c99'
CFLAGS = DEPFLAGS + " -mthumb -mcpu=cortex-m4 -mthumb-interwork -g3 " + (DEBUG ? "-O0 " : "-O2 ") +
    "-ffunction-sections -fdata-sections -fno-math-errno " +
    "-g -Wall " +
    "-mfloat-abi=softfp -mfpu=fpv4-sp-d16 "
CPPFLAGS = CFLAGS + ' -fno-rtti -fno-exceptions -std=gnu++14'

#arm-atollic-eabi-gcc Example\Utilities\lcd_log.o Example\User\ts_calibration.o Example\User\touchscreen.o #Example\User\stm32f4xx_it.o Example\User\mems.o Example\User\main.o Example\User\log.o Example\User\lcd.o Example\TrueSTUDIO\syscalls.o Example\TrueSTUDIO\startup_stm32f429xx.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_ll_fmc.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_spi.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_sdram.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_rcc_ex.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_rcc.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_pwr_ex.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_pwr.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_pcd.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_ltdc.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_i2c_ex.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_i2c.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_hcd.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_gpio.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_flash_ex.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_flash.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_dma2d.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_dma.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal_cortex.o Drivers\STM32F4xx_HAL_Driver\stm32f4xx_hal.o Drivers\CMSIS\system_stm32f4xx.o Drivers\BSP\STM32F429I-Discovery\stm32f429i_discovery_ts.o Drivers\BSP\STM32F429I-Discovery\stm32f429i_discovery_sdram.o Drivers\BSP\STM32F429I-Discovery\stm32f429i_discovery_lcd.o Drivers\BSP\STM32F429I-Discovery\stm32f429i_discovery_io.o Drivers\BSP\STM32F429I-Discovery\stm32f429i_discovery_gyroscope.o Drivers\BSP\STM32F429I-Discovery\stm32f429i_discovery_eeprom.o Drivers\BSP\STM32F429I-Discovery\stm32f429i_discovery.o Drivers\BSP\Components\stmpe811.o Drivers\BSP\Components\l3gd20.o Drivers\BSP\Components\ili9341.o -o STM32F429I-Discovery+EEPROM.elf -mthumb -mcpu=cortex-m4 -mfpu=fpv4-sp-d16 -T..\STM32F429ZI_FLASH.ld -Wl,--start-group -lc -lm -Wl,--end-group -static -Wl,-cref,-u,Reset_Handler -Wl,-Map=STM32F429I-Discovery+EEPROM.map -Wl,--gc-sections -Wl,--defsym=malloc_getpagesize_P=0x1000

# Linker script to be used.
if F405
LSCRIPT = "#{PROG}/STM32F405_FLASH.ld"
else
LSCRIPT = "#{PROG}/STM32F429ZI_FLASH.ld"
end

LOPTIONS = [
#  "--specs=nosys.specs",
#   "--specs=rdimon.specs",
#   "--specs=nano.specs",
#   "-u _printf_float -u _scanf_float",
#  "-lstdc++_s -lsupc++_s -lm -lgcc -lc_s -lgcc -lc_s" # newlib nano
#  "-lstdc++ -lsupc++ -lm -lgcc -lc -lgcc -lc" # newlib
]

LDFLAGS = " #{CFLAGS} -T#{LSCRIPT} " + " -fno-rtti -fno-exceptions " + "-Wl,--wrap=malloc,--wrap=realloc,--wrap=free " +
  "-Wl,--start-group -Wl,--end-group -static -Wl,-cref,-u,Reset_Handler -Wl,-Map=#{OBJDIR}/#{PROG}.map -Wl,--gc-sections -Wl,--defsym=malloc_getpagesize_P=0x1000 " +
  LOPTIONS.join(" ")
   # " --specs=nosys.specs " +
   # " --specs=rdimon.specs --specs=nano.specs -u _printf_float -u _scanf_float -lstdc++_s -lsupc++_s -lm -lgcc -lc_s -lgcc -lc_s " # -lnosys "

# tasks
# desc "Upload via stlink"
# task :upload do
#   sh "./flashit #{OBJDIR}/#{PROG}.bin"
# end

desc "Upload via openocd"
task :upload do
  sh "./flashit.openocd #{OBJDIR}/#{PROG}.elf"
end

desc "Upload via dfu"
task :dfu do
  sh "/usr/bin/dfu-util -v -R -d 0483:df11 -a 0 --dfuse-address 0x08000000 -D #{OBJDIR}/#{PROG}.bin"
end

# generate the header dependencies if they exist
import(*DEPFILES)

task :clean do
  FileUtils.rm_rf(OBJDIR)
end

task :default => [:build]

task :build => ["#{PROG}.bin", :size]

task :size do
  sh "#{SIZE} #{OBJDIR}/#{PROG}.elf"
end

task :disasm do
  sh "#{OBJDUMP} -d -f -M reg-names-std --demangle #{OBJDIR}/#{PROG}.elf > #{OBJDIR}/#{PROG}.disasm"
end

task :makelibs do
  sh "#{AR} #{ARFLAGS} hal.a #{LIB_OBJS}"
end

file "#{PROG}.bin" => ["#{PROG}.elf"] do
  sh "#{OBJCOPY} -O binary #{OBJDIR}/#{PROG}.elf #{OBJDIR}/#{PROG}.bin"
end

file "#{PROG}.elf" => OBJ do |t|
  puts "Linking for #{TARGET}"
  sh "#{$using_cpp ? LDCPP : LD} #{LDFLAGS} #{OBJ} #{LIBS} -o #{OBJDIR}/#{t.name}"
end

#arm-none-eabi-objcopy -R .stack -O ihex ../LPC1768/main.elf ../LPC1768/main.hex
#arm-none-eabi-objdump -d -f -M reg-names-std --demangle ../LPC1768/main.elf >../LPC1768/main.disasm

rule '.o' => lambda{ |objfile| obj2src(objfile, 'cpp') } do |t|
  puts "Compiling #{t.source} for #{TARGET}"
  sh "#{CCPP} #{CPPFLAGS} #{INCLUDE} #{DEFINES} -c -o #{t.name} #{t.source}"
end

rule '.o' => lambda{ |objfile| obj2src(objfile, 'c') } do |t|
  puts "Compiling #{t.source} for #{TARGET}"
  sh "#{CC} #{CFLAGS} #{CSTD} #{INCLUDE} #{DEFINES} -c -o #{t.name} #{t.source}"
end

rule '.o' => lambda{ |objfile| obj2src(objfile, 's') } do |t|
  puts "Assembling #{t.source} for #{TARGET}"
  sh "#{CC} -c -mthumb -mcpu=cortex-m4 -mthumb-interwork -mlittle-endian -mfloat-abi=softfp -mfpu=fpv4-sp-d16 -g -Wa,--no-warn -x assembler-with-cpp #{INCLUDE} -o #{t.name} #{t.source}"
end
